"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDays = addDays;
exports.getDates = getDates;
exports.textWidth = textWidth;
exports.formatMonth = formatMonth;
exports.formatDay = formatDay;
exports.minDate = minDate;
exports.maxDate = maxDate;
exports.max = max;
exports.p2s = p2s;
exports.s2p = s2p;
exports.formatData = formatData;
exports.hasPath = hasPath;
exports.toposort = toposort;
exports.autoSchedule = autoSchedule;
exports.DAY = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DAY = 24 * 3600 * 1000;
exports.DAY = DAY;

function addDays(date, days) {
  var d = new Date(date.valueOf());
  d.setDate(d.getDate() + days);
  return d;
}

function getDates(begin, end) {
  var dates = [];
  var s = new Date(begin);
  s.setHours(24, 0, 0, 0);

  while (s.getTime() <= end) {
    dates.push(s.getTime());
    s = addDays(s, 1);
  }

  return dates;
}

var ctx = null;

function textWidth(text, font, pad) {
  ctx = ctx || document.createElement('canvas').getContext('2d');
  ctx.font = font;
  return ctx.measureText(text).width + pad;
}

function formatMonth(date) {
  var y = date.getFullYear();
  var m = date.getMonth() + 1;
  return "".concat(y, "/").concat(m > 9 ? m : "0".concat(m));
}

function formatDay(date) {
  var m = date.getMonth() + 1;
  var d = date.getDate();
  return "".concat(m, "/").concat(d);
}

function minDate(a, b) {
  if (a && b) {
    return a > b ? b : a;
  }

  return a || b;
}

function maxDate(a, b) {
  if (a && b) {
    return a < b ? b : a;
  }

  return a || b;
}

function max(list, defaultValue) {
  if (list.length) {
    return Math.max.apply(null, list);
  }

  return defaultValue;
}

function p2s(arr) {
  return arr.map(function (p) {
    return "".concat(p[0], ",").concat(p[1]);
  }).join(' ');
}

function s2p(str) {
  return str.split(' ').map(function (s) {
    var p = s.split(',');
    return [parseFloat(p[0]), parseFloat(p[1])];
  });
}

function walkLevel(nodes, level) {
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    node.level = "".concat(level).concat(i + 1);
    node.text = "".concat(node.level, " ").concat(node.name);
    walkLevel(node.children, "".concat(node.level, "."));
  }
}

function walkDates(nodes) {
  var start = null;
  var end = null;
  var percent = 0;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];

    if (node.children.length) {
      var tmp = walkDates(node.children);
      node.start = tmp.start;
      node.end = tmp.end;
      node.percent = tmp.percent;

      if (tmp.start && tmp.end) {
        node.duration = (tmp.end - tmp.start) / DAY;
      } else {
        node.duration = 0;
      }
    } else {
      node.percent = node.percent || 0;

      if (node.start) {
        node.end = addDays(node.start, node.duration || 0);
      }

      if (node.type === 'milestone') {
        node.end = node.start;
      }
    }

    start = minDate(start, node.start);
    end = maxDate(end, node.end);
    percent += node.percent;
  }

  if (nodes.length) {
    percent /= nodes.length;
  }

  return {
    start: start,
    end: end,
    percent: percent
  };
}

function formatData(tasks, links, walk) {
  var map = {};
  var tmp = tasks.map(function (t, i) {
    map[t.id] = i;
    return _objectSpread(_objectSpread({}, t), {}, {
      children: [],
      links: []
    });
  });
  var roots = [];
  tmp.forEach(function (t) {
    var parent = tmp[map[t.parent]];

    if (parent) {
      parent.children.push(t);
    } else {
      roots.push(t);
    }
  });
  links.forEach(function (l) {
    var s = tmp[map[l.source]];
    var t = tmp[map[l.target]];

    if (s && t) {
      s.links.push(l);
    }
  });
  walkLevel(roots, '');
  walkDates(roots);

  if (walk) {
    walk(roots);
  }

  var list = [];
  roots.forEach(function (r) {
    var stack = [];
    stack.push(r);

    while (stack.length) {
      var node = stack.pop();
      var len = node.children.length;

      if (len) {
        node.type = 'group';
      }

      list.push(node);

      for (var i = len - 1; i >= 0; i--) {
        stack.push(node.children[i]);
      }
    }
  });
  return list;
}

function hasPath(vmap, a, b) {
  var stack = [];
  stack.push(vmap[a]);

  while (stack.length) {
    var v = stack.pop();

    if (v.id === b) {
      return true;
    }

    for (var i = 0; i < v.links.length; i++) {
      stack.push(v.links[i]);
    }
  }

  return false;
}

function toposort(links) {
  var vmap = {};
  links.forEach(function (l) {
    var init = function init(id) {
      return {
        id: id,
        out: [],
        "in": 0
      };
    };

    vmap[l.source] = init(l.source);
    vmap[l.target] = init(l.target);
  });

  for (var i = 0; i < links.length; i++) {
    var l = links[i];
    vmap[l.target]["in"]++;
    vmap[l.source].out.push(i);
  }

  var s = Object.keys(vmap).map(function (k) {
    return vmap[k].id;
  }).filter(function (id) {
    return !vmap[id]["in"];
  });
  var sorted = [];

  while (s.length) {
    var id = s.pop();
    sorted.push(id);

    for (var _i = 0; _i < vmap[id].out.length; _i++) {
      var index = vmap[id].out[_i];
      var v = vmap[links[index].target];
      v["in"]--;

      if (!v["in"]) {
        s.push(v.id);
      }
    }
  }

  return sorted;
}

function autoSchedule(tasks, links) {
  var lockMilestone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var vmap = {};
  links.forEach(function (l) {
    vmap[l.source] = {
      id: l.source,
      links: []
    };
    vmap[l.target] = {
      id: l.target,
      links: []
    };
  });
  var dag = [];
  links.forEach(function (l) {
    var source = l.source,
        target = l.target;

    if (!hasPath(vmap, target, source)) {
      dag.push(l);
      vmap[source].links.push(vmap[target]);
    }
  });
  var sorted = toposort(dag);
  var tmap = {};

  for (var i = 0; i < tasks.length; i++) {
    var task = tasks[i];

    if (task.type === 'milestone') {
      task.duration = 0;
    }

    tmap[task.id] = i;
  }

  var ins = {};
  sorted.forEach(function (id) {
    ins[id] = [];
  });
  dag.forEach(function (l) {
    ins[l.target].push(l);
  });
  sorted.forEach(function (id) {
    var task = tasks[tmap[id]];
    if (!task) return;
    var days = task.duration || 0;

    if (lockMilestone && task.type === 'milestone') {
      return;
    }

    var start = null;
    var end = null;

    for (var _i2 = 0; _i2 < ins[id].length; _i2++) {
      var l = ins[id][_i2];
      var v = tasks[tmap[l.source]];

      if (v && v.start) {
        var s = addDays(v.start, l.lag || 0);
        var e = addDays(s, v.duration || 0);

        if (l.type === 'SS') {
          start = maxDate(start, s);
        }

        if (l.type === 'FS') {
          start = maxDate(start, e);
        }

        if (l.type === 'SF') {
          end = maxDate(end, s);
        }

        if (l.type === 'FF') {
          end = maxDate(end, e);
        }
      }
    }

    if (end) {
      task.start = addDays(end, -days);
    }

    if (start) {
      task.start = start;
    }
  });
}