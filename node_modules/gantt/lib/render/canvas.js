"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = render;

var _utils = require("../utils");

function render(vnode, ctx, e) {
  var tag = vnode.tag,
      props = vnode.props,
      children = vnode.children;

  if (tag === 'svg') {
    var width = props.width,
        height = props.height;
    ctx.width = width;
    ctx.height = height;
  }

  if (tag === 'line') {
    var x1 = props.x1,
        x2 = props.x2,
        y1 = props.y1,
        y2 = props.y2,
        _props$style = props.style,
        style = _props$style === void 0 ? {} : _props$style;

    if (style.stroke) {
      ctx.strokeStyle = style.stroke;
      ctx.lineWidth = parseFloat(style['stroke-width'] || 1);
    }

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  if (tag === 'polyline' || tag === 'polygon') {
    var points = props.points,
        _props$style2 = props.style,
        _style = _props$style2 === void 0 ? {} : _props$style2;

    var p = (0, _utils.s2p)(points);

    if (_style.stroke) {
      ctx.strokeStyle = _style.stroke;
      ctx.lineWidth = parseFloat(_style['stroke-width'] || 1);
    }

    if (_style.fill) {
      ctx.fillStyle = _style.fill;
    }

    ctx.beginPath();
    ctx.moveTo(p[0][0], p[0][1]);

    for (var i = 1; i < p.length; i++) {
      ctx.lineTo(p[i][0], p[i][1]);
    }

    if (tag === 'polyline') {
      ctx.stroke();
    } else {
      ctx.fill();
    }
  }

  if (tag === 'rect') {
    var x = props.x,
        y = props.y,
        _width = props.width,
        _height = props.height,
        _props$rx = props.rx,
        rx = _props$rx === void 0 ? 0 : _props$rx,
        _props$ry = props.ry,
        ry = _props$ry === void 0 ? 0 : _props$ry,
        onClick = props.onClick,
        _props$style3 = props.style,
        _style2 = _props$style3 === void 0 ? {} : _props$style3; // From https://github.com/canvg/canvg


    ctx.beginPath();
    ctx.moveTo(x + rx, y);
    ctx.lineTo(x + _width - rx, y);
    ctx.quadraticCurveTo(x + _width, y, x + _width, y + ry);
    ctx.lineTo(x + _width, y + _height - ry);
    ctx.quadraticCurveTo(x + _width, y + _height, x + _width - rx, y + _height);
    ctx.lineTo(x + rx, y + _height);
    ctx.quadraticCurveTo(x, y + _height, x, y + _height - ry);
    ctx.lineTo(x, y + ry);
    ctx.quadraticCurveTo(x, y, x + rx, y);

    if (e && onClick && ctx.isPointInPath(e.x, e.y)) {
      onClick();
    }

    ctx.closePath();

    if (_style2.fill) {
      ctx.fillStyle = _style2.fill;
    }

    ctx.fill();

    if (_style2.stroke) {
      ctx.strokeStyle = _style2.stroke;
      ctx.lineWidth = parseFloat(_style2['stroke-width'] || 1);
      ctx.stroke();
    }
  }

  if (tag === 'text') {
    var _x = props.x,
        _y = props.y,
        _style3 = props.style;

    if (_style3) {
      ctx.fillStyle = _style3.fill;
      var BL = {
        central: 'middle',
        middle: 'middle',
        hanging: 'hanging',
        alphabetic: 'alphabetic',
        ideographic: 'ideographic'
      };
      var AL = {
        start: 'start',
        middle: 'center',
        end: 'end'
      };
      ctx.textBaseline = BL[_style3['dominant-baseline']] || 'alphabetic';
      ctx.textAlign = AL[_style3['text-anchor']] || 'start';
      ctx.font = "".concat(_style3['font-weight'] || '', " ").concat(_style3['font-size'], " ").concat(_style3['font-family']);
    }

    ctx.fillText(children.join(''), _x, _y);
  }

  children.forEach(function (v) {
    if (typeof v !== 'string') {
      render(v, ctx, e);
    }
  });
}